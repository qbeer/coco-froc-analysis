window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "coco_froc_analysis", "modulename": "coco_froc_analysis", "kind": "module", "doc": "<h1 id=\"coco-froc-analysis\">COCO FROC analysis</h1>\n\n<p>FROC analysis for COCO annotations and Detectron(2) detection results. The COCO annotation style is defined <a href=\"https://cocodataset.org/\">here</a>.</p>\n\n<h3 id=\"installation\">Installation</h3>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>coco-froc-analysis\n</code></pre>\n</div>\n\n<h3 id=\"about\">About</h3>\n\n<p>A single annotation record in the ground-truth file might look like this:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;area&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">2120</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;iscrowd&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;bbox&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">111</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">53</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">40</span><span class=\"p\">],</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;category_id&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;ignore&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;segmentation&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[],</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;image_id&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">407</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;id&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">945</span>\n<span class=\"p\">}</span>\n</code></pre>\n</div>\n\n<p>While the prediction (here for bounding box) given by the region detection framework is such:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;image_id&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">407</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;category_id&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;score&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mf\">0.9990422129631042</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"nt\">&quot;bbox&quot;</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span>\n<span class=\"w\">    </span><span class=\"mf\">110.72555541992188</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">13.9161834716797</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">49.4566650390625</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mf\">36.65155029296875</span>\n<span class=\"w\">  </span><span class=\"p\">]</span>\n<span class=\"p\">}</span>\n</code></pre>\n</div>\n\n<p>The FROC analysis counts the number of images, number of lesions in the ground truth file for all categories and then counts the lesion localization predictions and the non-lesion localization predictions. A lesion is localized by default if its center is inside any ground truth box and the categories match or if you wish to use IoU you should provide threshold upon which you can define the 'close enough' relation.</p>\n\n<h2 id=\"usage\">Usage</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">coco_froc_analysis.count</span> <span class=\"kn\">import</span> <span class=\"n\">generate_bootstrap_count_curves</span>\n<span class=\"kn\">from</span> <span class=\"nn\">coco_froc_analysis.count</span> <span class=\"kn\">import</span> <span class=\"n\">generate_count_curve</span>\n<span class=\"kn\">from</span> <span class=\"nn\">coco_froc_analysis.froc</span> <span class=\"kn\">import</span> <span class=\"n\">generate_bootstrap_froc_curves</span>\n<span class=\"kn\">from</span> <span class=\"nn\">coco_froc_analysis.froc</span> <span class=\"kn\">import</span> <span class=\"n\">generate_froc_curve</span>\n\n<span class=\"c1\"># For single FROC curve</span>\n<span class=\"n\">generate_froc_curve</span><span class=\"p\">(</span>\n            <span class=\"n\">gt_ann</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">gt_ann</span><span class=\"p\">,</span>\n            <span class=\"n\">pr_ann</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">pr_ann</span><span class=\"p\">,</span>\n            <span class=\"n\">use_iou</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">use_iou</span><span class=\"p\">,</span>\n            <span class=\"n\">iou_thres</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">iou_thres</span><span class=\"p\">,</span>\n            <span class=\"n\">n_sample_points</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">n_sample_points</span><span class=\"p\">,</span>\n            <span class=\"n\">plot_title</span><span class=\"o\">=</span><span class=\"s1\">&#39;FROC&#39;</span> <span class=\"k\">if</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">plot_title</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"k\">else</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">plot_title</span><span class=\"p\">,</span>\n            <span class=\"n\">plot_output_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;froc.png&#39;</span> <span class=\"k\">if</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">plot_output_path</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"k\">else</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">plot_output_path</span><span class=\"p\">,</span>\n            <span class=\"n\">test_ann</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">test_ann</span><span class=\"p\">,</span>\n        <span class=\"p\">)</span>\n\n<span class=\"c1\"># For bootstrapped curves</span>\n<span class=\"n\">generate_bootstrap_froc_curves</span><span class=\"p\">(</span>\n            <span class=\"n\">gt_ann</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">gt_ann</span><span class=\"p\">,</span>\n            <span class=\"n\">pr_ann</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">pr_ann</span><span class=\"p\">,</span>\n            <span class=\"n\">n_bootstrap_samples</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">bootstrap</span><span class=\"p\">,</span>\n            <span class=\"n\">use_iou</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">use_iou</span><span class=\"p\">,</span>\n            <span class=\"n\">iou_thres</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">iou_thres</span><span class=\"p\">,</span>\n            <span class=\"n\">n_sample_points</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">n_sample_points</span><span class=\"p\">,</span>\n            <span class=\"n\">plot_title</span><span class=\"o\">=</span><span class=\"s1\">&#39;FROC (bootstrap)&#39;</span> <span class=\"k\">if</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">plot_title</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"k\">else</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">plot_title</span><span class=\"p\">,</span>\n            <span class=\"n\">plot_output_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;froc_bootstrap.png&#39;</span> <span class=\"k\">if</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">plot_output_path</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"k\">else</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">plot_output_path</span><span class=\"p\">,</span>\n            <span class=\"n\">test_ann</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">test_ann</span><span class=\"p\">,</span>\n        <span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Please check <code>run.py</code> for more details. The <code>IoU</code> part of this code is not reliable and currently the codebase only works for binary evaluation, but any multiclass problem could be chunked up to work with it.</p>\n\n<p>Description of <code>run.py</code> arguments:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>usage:<span class=\"w\"> </span>run.py<span class=\"w\"> </span><span class=\"o\">[</span>-h<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--bootstrap<span class=\"w\"> </span>BOOTSTRAP<span class=\"o\">]</span><span class=\"w\"> </span>--gt_ann<span class=\"w\"> </span>GT_ANN<span class=\"w\"> </span>--pr_ann<span class=\"w\"> </span>PR_ANN<span class=\"w\"> </span><span class=\"o\">[</span>--use_iou<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--iou_thres<span class=\"w\"> </span>IOU_THRES<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--n_sample_points<span class=\"w\"> </span>N_SAMPLE_POINTS<span class=\"o\">]</span>\n<span class=\"w\">              </span><span class=\"o\">[</span>--plot_title<span class=\"w\"> </span>PLOT_TITLE<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--plot_output_path<span class=\"w\"> </span>PLOT_OUTPUT_PATH<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--test_ann<span class=\"w\"> </span>TEST_ANN<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--counts<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--weighted<span class=\"o\">]</span>\n\noptional<span class=\"w\"> </span>arguments:\n<span class=\"w\">  </span>-h,<span class=\"w\"> </span>--help<span class=\"w\">            </span>show<span class=\"w\"> </span>this<span class=\"w\"> </span><span class=\"nb\">help</span><span class=\"w\"> </span>message<span class=\"w\"> </span>and<span class=\"w\"> </span><span class=\"nb\">exit</span>\n<span class=\"w\">  </span>--bootstrap<span class=\"w\"> </span>BOOTSTRAP\n<span class=\"w\">                        </span>Whether<span class=\"w\"> </span>to<span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span>a<span class=\"w\"> </span>single<span class=\"w\"> </span>or<span class=\"w\"> </span>bootstrap<span class=\"w\"> </span>runs.\n<span class=\"w\">  </span>--gt_ann<span class=\"w\"> </span>GT_ANN\n<span class=\"w\">  </span>--pr_ann<span class=\"w\"> </span>PR_ANN\n<span class=\"w\">  </span>--use_iou<span class=\"w\">             </span>Use<span class=\"w\"> </span>IoU<span class=\"w\"> </span>score<span class=\"w\"> </span>to<span class=\"w\"> </span>decide<span class=\"w\"> </span>based<span class=\"w\"> </span>on<span class=\"w\"> </span><span class=\"sb\">`</span>proximity<span class=\"sb\">`</span>\n<span class=\"w\">  </span>--iou_thres<span class=\"w\"> </span>IOU_THRES\n<span class=\"w\">                        </span>If<span class=\"w\"> </span>IoU<span class=\"w\"> </span>score<span class=\"w\"> </span>is<span class=\"w\"> </span>used<span class=\"w\"> </span>the<span class=\"w\"> </span>default<span class=\"w\"> </span>threshold<span class=\"w\"> </span>is<span class=\"w\"> </span><span class=\"nb\">set</span><span class=\"w\"> </span>to<span class=\"w\"> </span>.5\n<span class=\"w\">  </span>--n_sample_points<span class=\"w\"> </span>N_SAMPLE_POINTS\n<span class=\"w\">                        </span>Number<span class=\"w\"> </span>of<span class=\"w\"> </span>points<span class=\"w\"> </span>to<span class=\"w\"> </span>evaluate<span class=\"w\"> </span>the<span class=\"w\"> </span>FROC<span class=\"w\"> </span>curve<span class=\"w\"> </span>at.\n<span class=\"w\">  </span>--plot_title<span class=\"w\"> </span>PLOT_TITLE\n<span class=\"w\">  </span>--plot_output_path<span class=\"w\"> </span>PLOT_OUTPUT_PATH\n<span class=\"w\">  </span>--test_ann<span class=\"w\"> </span>TEST_ANN<span class=\"w\">   </span>Extra<span class=\"w\"> </span>ground-truth<span class=\"w\"> </span>like<span class=\"w\"> </span>annotations\n<span class=\"w\">  </span>--counts\n<span class=\"w\">  </span>--weighted\n</code></pre>\n</div>\n\n<h2 id=\"cli-usage\">CLI Usage</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>python<span class=\"w\"> </span>-m<span class=\"w\"> </span>coco_froc_analysis<span class=\"w\"> </span><span class=\"o\">[</span>-h<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--bootstrap<span class=\"w\"> </span>N_BOOTSTRAP_ROUNDS<span class=\"o\">]</span><span class=\"w\"> </span>--gt_ann<span class=\"w\"> </span>GT_ANN<span class=\"w\"> </span>--pred_ann<span class=\"w\"> </span>PRED_ANN<span class=\"w\"> </span><span class=\"o\">[</span>--use_iou<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--iou_thres<span class=\"w\"> </span>IOU_THRES<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--n_sample_points<span class=\"w\"> </span>N_SAMPLE_POINTS<span class=\"o\">]</span>\n<span class=\"w\">                        </span><span class=\"o\">[</span>--plot_title<span class=\"w\"> </span>PLOT_TITLE<span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span>--plot_output_path<span class=\"w\"> </span>PLOT_OUTPUT_PATH<span class=\"o\">]</span>\n\noptional<span class=\"w\"> </span>arguments:\n<span class=\"w\">  </span>-h,<span class=\"w\"> </span>--help<span class=\"w\">            </span>show<span class=\"w\"> </span>this<span class=\"w\"> </span><span class=\"nb\">help</span><span class=\"w\"> </span>message<span class=\"w\"> </span>and<span class=\"w\"> </span><span class=\"nb\">exit</span>\n<span class=\"w\">  </span>--bootstrap<span class=\"w\">  </span>N_ROUNDS<span class=\"w\"> </span>Whether<span class=\"w\"> </span>to<span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span>a<span class=\"w\"> </span>single<span class=\"w\"> </span>or<span class=\"w\"> </span>bootstrap<span class=\"w\"> </span>runs.\n<span class=\"w\">  </span>--gt_ann<span class=\"w\"> </span>GT_ANN\n<span class=\"w\">  </span>--pred_ann<span class=\"w\"> </span>PRED_ANN\n<span class=\"w\">  </span>--use_iou<span class=\"w\">             </span>Use<span class=\"w\"> </span>IoU<span class=\"w\"> </span>score<span class=\"w\"> </span>to<span class=\"w\"> </span>decide<span class=\"w\"> </span>on<span class=\"w\"> </span><span class=\"sb\">`</span>proximity<span class=\"sb\">`</span><span class=\"w\"> </span>rather<span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span>using<span class=\"w\"> </span>center<span class=\"w\"> </span>pixel<span class=\"w\"> </span>inside<span class=\"w\"> </span>GT<span class=\"w\"> </span>box.\n<span class=\"w\">  </span>--iou_thres<span class=\"w\"> </span>IOU_THRES\n<span class=\"w\">                        </span>If<span class=\"w\"> </span>IoU<span class=\"w\"> </span>score<span class=\"w\"> </span>is<span class=\"w\"> </span>used<span class=\"w\"> </span>the<span class=\"w\"> </span>default<span class=\"w\"> </span>threshold<span class=\"w\"> </span>is<span class=\"w\"> </span>arbitrarily<span class=\"w\"> </span><span class=\"nb\">set</span><span class=\"w\"> </span>to<span class=\"w\"> </span>.5\n<span class=\"w\">  </span>--n_sample_points<span class=\"w\"> </span>N_SAMPLE_POINTS\n<span class=\"w\">                        </span>Number<span class=\"w\"> </span>of<span class=\"w\"> </span>points<span class=\"w\"> </span>to<span class=\"w\"> </span>evaluate<span class=\"w\"> </span>the<span class=\"w\"> </span>FROC<span class=\"w\"> </span>curve<span class=\"w\"> </span>at.\n<span class=\"w\">  </span>--plot_title<span class=\"w\"> </span>PLOT_TITLE\n<span class=\"w\">  </span>--plot_output_path<span class=\"w\"> </span>PLOT_OUTPUT_PATH\n</code></pre>\n</div>\n\n<p>By default centroid closeness is used, if the <code>--use_iou</code> flag is set, <code>--iou_thres</code> defaults to <code>.75</code> while the <code>--score_thres</code> score defaults to <code>.5</code>. The code outputs the FROC curve on the given detection results and GT dataset.</p>\n\n<h2 id=\"for-developers\">For developers</h2>\n\n<h3 id=\"installing\">Installing</h3>\n\n<p>In order to develop this repository you are in need of <code>poetry</code>. To install the latest version of <code>poetry</code> please run:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>curl<span class=\"w\"> </span>-sSL<span class=\"w\"> </span>https://install.python-poetry.org<span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>python3<span class=\"w\"> </span>-\n</code></pre>\n</div>\n\n<p>After that you can install the dependencies by running:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>poetry<span class=\"w\"> </span>install\n</code></pre>\n</div>\n\n<p>This will install the dependencies and the package in the virtual environment that you can activate by running:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>poetry<span class=\"w\"> </span>shell\n</code></pre>\n</div>\n\n<p>In order to have checks ready before pushing you should also install <code>pre-commit</code>:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pre-commit<span class=\"w\"> </span>install\n</code></pre>\n</div>\n\n<h3 id=\"running-tests\">Running tests</h3>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>python<span class=\"w\"> </span>-m<span class=\"w\"> </span>coverage<span class=\"w\"> </span>run<span class=\"w\"> </span>-m<span class=\"w\"> </span>unittest<span class=\"w\"> </span>discover<span class=\"w\"> </span>--pattern<span class=\"w\"> </span><span class=\"s2\">&quot;*_test.py&quot;</span><span class=\"w\"> </span>-v\npython<span class=\"w\"> </span>-m<span class=\"w\"> </span>coverage<span class=\"w\"> </span>report<span class=\"w\"> </span>-m\n</code></pre>\n</div>\n\n<h3 id=\"testing-github-actions-locally\">Testing GitHub Actions locally</h3>\n\n<p>Install <code>act</code> following the instructions <a href=\"https://nektosact.com/installation/index.html\">here</a>.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>curl<span class=\"w\"> </span>--proto<span class=\"w\"> </span><span class=\"s1\">&#39;=https&#39;</span><span class=\"w\"> </span>--tlsv1.2<span class=\"w\"> </span>-sSf<span class=\"w\"> </span>https://raw.githubusercontent.com/nektos/act/master/install.sh<span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>sudo<span class=\"w\"> </span>bash\n</code></pre>\n</div>\n\n<p>Then you can run the GitHub Actions locally by running:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>act\n</code></pre>\n</div>\n\n<p>This will always fail at the last step because the repository needs the <code>CODECOV_TOKEN</code> to be set in the repository secrets. This is not present locally, but this is not an ERROR.</p>\n\n<h3 id=\"creating-documentation\">Creating documentation</h3>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pdoc<span class=\"w\"> </span>-d<span class=\"w\"> </span>google<span class=\"w\"> </span>coco_froc_analysis<span class=\"w\"> </span>-o<span class=\"w\"> </span>docs<span class=\"w\"> </span><span class=\"c1\"># build docs</span>\n</code></pre>\n</div>\n\n<p>@Regards, Alex</p>\n\n<pre><code>@misc{qbeer,\n  author       = {Alex Olar},\n  title        = {FROC analysis for COCO-like file format},\n  howpublished = {GitHub repository},\n  month        = {September},\n  year         = {2022},\n  url          = {https://github.com/qbeer/coco-froc-analysis}\n}\n</code></pre>\n"}, {"fullname": "coco_froc_analysis.count", "modulename": "coco_froc_analysis.count", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coco_froc_analysis.count.bootstrap_count_curve", "modulename": "coco_froc_analysis.count.bootstrap_count_curve", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coco_froc_analysis.count.bootstrap_count_curve.generate_bootstrap_count_curves", "modulename": "coco_froc_analysis.count.bootstrap_count_curve", "qualname": "generate_bootstrap_count_curves", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gt_ann</span>,</span><span class=\"param\">\t<span class=\"n\">pr_ann</span>,</span><span class=\"param\">\t<span class=\"n\">weighted</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">n_sample_points</span><span class=\"o\">=</span><span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">n_bootstrap_samples</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">plot_title</span><span class=\"o\">=</span><span class=\"s1\">&#39;Count curve&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">plot_output_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;counts.png&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">test_ann</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bounds</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.count.count_curve", "modulename": "coco_froc_analysis.count.count_curve", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coco_froc_analysis.count.count_curve.count_point", "modulename": "coco_froc_analysis.count.count_curve", "qualname": "count_point", "kind": "function", "doc": "<p>Computes statistics based on ground truth annotations and predicted annotations.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>gt_ann (str): Path to the ground truth annotations file in JSON format.</li>\n<li>pr_ann (str): Path to the predicted annotations file in JSON format.</li>\n<li>score_thres (float): Score threshold for predicted annotations.</li>\n<li>weighted (bool): Flag indicating whether to compute weighted count statistics.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>stats (dict): Dictionary containing statistics for each category.</li>\n</ul>\n\n<p>This function loads ground truth and predicted annotations from JSON files,\nupdates the predicted scores based on the given score threshold, initializes\ncount statistics, builds dictionaries mapping annotation IDs to annotations,\nand updates the statistics based on matched annotations. It returns the computed\ncount statistics.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gt_ann</span>, </span><span class=\"param\"><span class=\"n\">pr_ann</span>, </span><span class=\"param\"><span class=\"n\">score_thres</span>, </span><span class=\"param\"><span class=\"n\">weighted</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.count.count_curve.calc_scores", "modulename": "coco_froc_analysis.count.count_curve", "qualname": "calc_scores", "kind": "function", "doc": "<p>Calculates precision and recall based on count statistics.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>stats (dict): Count statistics for each category.</li>\n<li>precision (dict): Dictionary to store precision per category.</li>\n<li>recall (dict): Dictionary to store recall per category.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>precision (dict): Updated precision dictionary.</li>\n<li>recall (dict): Updated recall dictionary.</li>\n</ul>\n\n<p>This function calculates precision and recall for each category based on the provided\ncount statistics. Precision represents the proportion of true positive counts divided\nby the sum of true positive and false positive counts. Recall represents the proportion\nof true positive counts divided by the sum of true positive and false negative counts.\nIt updates the respective dictionaries and returns the updated values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">stats</span>, </span><span class=\"param\"><span class=\"n\">precision</span>, </span><span class=\"param\"><span class=\"n\">recall</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.count.count_curve.generate_count_curve", "modulename": "coco_froc_analysis.count.count_curve", "qualname": "generate_count_curve", "kind": "function", "doc": "<p>Generates a count curve based on ground truth annotations and predicted annotations.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>gt_ann (str): Path to the ground truth annotations file in JSON format.</li>\n<li>pr_ann (str): Path to the predicted annotations file in JSON format.</li>\n<li>weighted (bool): Flag indicating whether to compute weighted count statistics.\nDefault value is False.</li>\n<li>n_sample_points (int): Number of sample points to generate on the count curve.\nDefault value is 50.</li>\n<li>plot_title (str): Title for the generated count curve plot. Default title is \"Count curve\".</li>\n<li>plot_output_path (str): Path to save the generated count curve plot. Default path is\n\"counts.png\".</li>\n<li>test_ann (list): List of tuples containing additional annotations for testing,\nwhere each tuple contains annotation data and a label. Default value is None.</li>\n<li>bounds (tuple): Tuple containing the minimum and maximum bounds for the x and y\naxes of the plot, respectively. Default value is None.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>None</li>\n</ul>\n\n<p>This function generates a count curve based on ground truth annotations (<code>gt_ann</code>)\nand predicted annotations (<code>pr_ann</code>). It computes precision and recall at different\noperating points along the curve. The generated curve is plotted with optional\nadditional annotations for testing. The resulting plot is saved at the specified\n<code>plot_output_path</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gt_ann</span>,</span><span class=\"param\">\t<span class=\"n\">pr_ann</span>,</span><span class=\"param\">\t<span class=\"n\">weighted</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">n_sample_points</span><span class=\"o\">=</span><span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">plot_title</span><span class=\"o\">=</span><span class=\"s1\">&#39;Count curve&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">plot_output_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;counts.png&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">test_ann</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bounds</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.count.count_stats", "modulename": "coco_froc_analysis.count.count_stats", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coco_froc_analysis.count.count_stats.init_stats", "modulename": "coco_froc_analysis.count.count_stats", "qualname": "init_stats", "kind": "function", "doc": "<p>Initializes statistics for each category based on ground truth annotations.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>gt (dict): Ground truth annotations containing information about categories.</li>\n<li>categories (dict): Dictionary containing category information.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>stats (dict): Dictionary containing initialized statistics for each category.</li>\n</ul>\n\n<p>This function initializes statistics for each category based on the provided\nground truth annotations and categories information. It creates a dictionary\nwith keys as category IDs and values as dictionaries containing the category name\nalong with initialized counts for true positives (TP), false positives (FP),\nfalse negatives (FN), and total predictions (P).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gt</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">categories</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.count.count_stats.update_stats", "modulename": "coco_froc_analysis.count.count_stats", "qualname": "update_stats", "kind": "function", "doc": "<p>Updates statistics based on ground truth and predicted annotations.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>stats (dict): Current statistics for each category.</li>\n<li>gt_id_to_annotation (dict): Mapping of image IDs to ground truth annotations.</li>\n<li>pr_id_to_annotation (dict): Mapping of image IDs to predicted annotations.</li>\n<li>categories (dict): Dictionary containing category information.</li>\n<li>weighted (bool): Flag indicating whether to use weighted matching.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>stats (dict): Updated statistics for each category.</li>\n</ul>\n\n<p>This function updates statistics for each category based on the provided\nground truth and predicted annotations. It creates a cost matrix between\nground truth annotations and predicted annotations based on overlap area\nif <code>weighted</code> is True, or Euclidean distance if False. It then applies\nthe Hungarian algorithm to find the optimal assignment of annotations,\nminimizing the total cost. The computed true positives (TP), false positives\n(FP), and false negatives (FN) are updated accordingly in the <code>stats</code>\ndictionary and returned.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">stats</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">gt_id_to_annotation</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">pr_id_to_annotation</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">categories</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">weighted</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.froc", "modulename": "coco_froc_analysis.froc", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coco_froc_analysis.froc.bootstrap_froc_curve", "modulename": "coco_froc_analysis.froc.bootstrap_froc_curve", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coco_froc_analysis.froc.bootstrap_froc_curve.run_bootstrap", "modulename": "coco_froc_analysis.froc.bootstrap_froc_curve", "qualname": "run_bootstrap", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">args</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.froc.bootstrap_froc_curve.generate_bootstrap_froc_curves", "modulename": "coco_froc_analysis.froc.bootstrap_froc_curve", "qualname": "generate_bootstrap_froc_curves", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gt_ann</span>,</span><span class=\"param\">\t<span class=\"n\">pr_ann</span>,</span><span class=\"param\">\t<span class=\"n\">n_bootstrap_samples</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">use_iou</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">iou_thres</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">n_sample_points</span><span class=\"o\">=</span><span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">plot_title</span><span class=\"o\">=</span><span class=\"s1\">&#39;Bootstrap FROC&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">plot_output_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;froc_bootstrapped.png&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">test_ann</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bounds</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.froc.froc_curve", "modulename": "coco_froc_analysis.froc.froc_curve", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coco_froc_analysis.froc.froc_curve.froc_point", "modulename": "coco_froc_analysis.froc.froc_curve", "qualname": "froc_point", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gt</span>, </span><span class=\"param\"><span class=\"n\">pr</span>, </span><span class=\"param\"><span class=\"n\">score_thres</span>, </span><span class=\"param\"><span class=\"n\">use_iou</span>, </span><span class=\"param\"><span class=\"n\">iou_thres</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.froc.froc_curve.calc_scores", "modulename": "coco_froc_analysis.froc.froc_curve", "qualname": "calc_scores", "kind": "function", "doc": "<p>Calculates Sensitivity and False Positive Rate (FPR) based on FROC statistics.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>stats (dict): FROC statistics for each category.</li>\n<li>lls_accuracy (dict): Dictionary to store Sensitivity per category.</li>\n<li>nlls_per_image (dict): Dictionary to store FPR per image per category.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>lls_accuracy (dict): Updated Sensitivity dictionary.</li>\n<li>nlls_per_image (dict): Updated FPR per image dictionary.</li>\n</ul>\n\n<p>This function calculates Sensitivity (True Positive Rate) and False Positive Rate (FPR)\nfor each category based on the provided FROC statistics. Sensitivity represents the\nproportion of correctly detected lesions (True Positives) divided by the total number\nof lesions present in the ground truth data. FPR represents the proportion of falsely\ndetected lesions (False Positives) divided by the total number of images. The function\nupdates the respective dictionaries and returns the updated values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">stats</span>, </span><span class=\"param\"><span class=\"n\">lls_accuracy</span>, </span><span class=\"param\"><span class=\"n\">nlls_per_image</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.froc.froc_curve.generate_froc_curve", "modulename": "coco_froc_analysis.froc.froc_curve", "qualname": "generate_froc_curve", "kind": "function", "doc": "<p>Generates a Free-Response Receiver Operating Characteristic (FROC) curve based on\nground truth annotations and predicted annotations.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>gt_ann (str): Path to the ground truth annotations file in JSON format.</li>\n<li>pr_ann (str): Path to the predicted annotations file in JSON format.</li>\n<li>use_iou (bool): Flag indicating whether to use Intersection over Union (IoU) for\nmatching annotations. Default value is False.</li>\n<li>iou_thres (float): IoU threshold for matching annotations if <code>use_iou</code> is True.\nDefault value is 0.5.</li>\n<li>n_sample_points (int): Number of sample points to generate on the FROC curve.\nDefaults value 50.</li>\n<li>plot_title (str): Title for the generated FROC curve plot. Default title is \"FROC curve\".</li>\n<li>plot_output_path (str): Path to save the generated FROC curve plot. Default path is\n\"froc.png\".</li>\n<li>test_ann (list): List of tuples containing additional annotations for testing,\nwhere each tuple contains annotation data and a label. Default value is None.</li>\n<li>bounds (tuple): Tuple containing the minimum and maximum bounds for the x and y\naxes of the plot, respectively. Defaults value is None.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>None</li>\n</ul>\n\n<p>This function generates a Free-Response Receiver Operating Characteristic (FROC) curve\nbased on ground truth annotations (<code>gt_ann</code>) and predicted annotations (<code>pr_ann</code>). It\ncomputes the sensitivity and false positive rate (FPR) at different operating points\nalong the curve. The generated curve is plotted with optional additional annotations\nfor testing. The resulting plot is saved at the specified <code>plot_output_path</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gt_ann</span>,</span><span class=\"param\">\t<span class=\"n\">pr_ann</span>,</span><span class=\"param\">\t<span class=\"n\">use_iou</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">iou_thres</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">n_sample_points</span><span class=\"o\">=</span><span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">plot_title</span><span class=\"o\">=</span><span class=\"s1\">&#39;FROC curve&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">plot_output_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;froc.png&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">test_ann</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bounds</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.froc.froc_stats", "modulename": "coco_froc_analysis.froc.froc_stats", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "coco_froc_analysis.froc.froc_stats.init_stats", "modulename": "coco_froc_analysis.froc.froc_stats", "qualname": "init_stats", "kind": "function", "doc": "<p>Initializing the statistics before counting leasion\n   and non-leasion localiazations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li>gt {dict} -- Ground truth COCO dataset</li>\n<li>categories {dict} -- Dictionary of categories in the COCO dataset</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>stats {dict} -- Statistics to be updated, containing every information\n                  necessary to evaluate a single FROC point</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gt</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">categories</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "coco_froc_analysis.froc.froc_stats.update_stats", "modulename": "coco_froc_analysis.froc.froc_stats", "qualname": "update_stats", "kind": "function", "doc": "<p>Updating statistics as going through images of the dataset.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li>stats {dict} -- FROC statistics</li>\n<li>gt_id_to_annotation {dict} -- Ground-truth image IDs to annotations.</li>\n<li>pr_id_to_annotation {dict} -- Prediction image IDs to annotations.</li>\n<li>categories {dict} -- COCO categories dictionary.</li>\n<li>use_iou {bool} -- Whether or not to use iou thresholding.</li>\n<li>iou_thres {float} -- IoU threshold when using IoU thresholding.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>stats {dict} -- Updated FROC statistics</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">stats</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">gt_id_to_annotation</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">pr_id_to_annotation</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">categories</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">use_iou</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">iou_thres</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();
